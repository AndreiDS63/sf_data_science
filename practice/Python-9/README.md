<div id="header" align="center">
  <img src="https://github.com/devicons/devicon/blob/master/icons/python/python-original.svg" width="100" title="Python" alt="Python" width="100" height="100"/>
</div>


<div id="badges" align="center">
    <img src="https://komarev.com/ghpvc/?username=AndreiDS63&style=flat-square&color=blue" alt=""/>

</div>

# 1. Python-9


## Оглавление 
* [Модуль Collections](#модуль-collections-counter-и-defaultdict)  
    + [Counter](#counter)
    + [Defaultdict](#defaultdict)
    + [Orderdict](#ordereddict)
    + [Deque](#deque)
* [Модуль NumPy. Типы данных](#модуль-numpy-типы-данных)  
    + [Целочисленные типы](#целочисленные-типы-данных-в-numpy)
    + [С плавающей точкой](#типы-данных-с-плавающей-точкой-в-numpy)
    + [Дополнительные типы](#дополнительные-типы-данных-в-numpy)  
* [Модуль NumPy. Массивы](#модуль-numpy-типы-данных)  
    + [Массивы В NumPy](#массивы-в-numpy)  
    + [Заполнение новых массивов](#заполнение-новых-массивов)  
* [7. Модуль NumPy. Действия с массивами](#7-модуль-numpy-действия-с-массивами)
    + [Действия с массивами](#действия-с-массивами)
* [8. Модуль NumPy. Операции с векторами](#модуль-numpy-операции-с-векторами)
    + [ВЕКТОРЫ В NUMPY И АРИФМЕТИКА](#векторы-в-numpy-и-арифметика)
    + [ПРОДВИНУТЫЕ ОПЕРАЦИИ С ВЕКТОРАМИ](#продвинутые-операции-с-векторами)
    + [БАЗОВЫЕ СТАТИСТИЧЕСКИЕ ФУНКЦИИ ДЛЯ ВЕКТОРОВ](#базовые-статистические-функции-для-векторов)
* [Модуль NumPy. Случайные числа](#модуль-numpy-случайные-числа)
    + [СЛУЧАЙНЫЕ ЧИСЛА В NUMPY](#случайные-числа-в-numpy)



---

### Модуль Collections
- как подсчитывать элементы в списке с помощью объекта Counter;  
- как создавать словарь с заданным по умолчанию объектом для упрощения написания кода;  
- как создавать объекты deque и OrderedDict;  
- как применять возможности очереди и стека на практике;  
-  как определять ситуации, в которых необходимо использовать новые изученные объекты вместо привычных list и dict.

---

#### COUNTER
Предназначен для решения часто возникающей задачи по подсчёту различных элементов  

№ п/п |код     | Описание
:----:|:------:|:----------:
1     |`from collections import Counter`|
2     |`c = Counter(lst)`|узнать сколько раз встретился конкретный элемент
3     |`sum(c.values())`|узнать сумму всех значений
4     |`Counter(lst1) + Counter(lst2)`| 
5     |`Counter(lst1).substract(Counter(lst2))`| 
6     |`print(*Counter(lst1).elements())`|список всех элементов
7     |`print(list(Counter(lst1)))`|список уникальных элементов 
8     |`print(dict(Counter(lst1)))`|превратить Counter в обычный словарь
9     |`print(Counter(lst).most_common())`|список кортежей
10     |`print(Counter(lst).most_common(2))`|список из 2х кортежей
11     |`Counter(lst).clear()`|обнулить счетчик

:arrow_up:[К оглавлению](#оглавление)

---

#### DEFAULTDICT
Позволяет задавать тот тип данных, который хранится в словаре по умолчанию. Бывает удобно в том случае, если приходится заполнять одну и ту же структуру данных, экземпляр которой должен храниться по каждому ключу в словаре.  

`from collections import defaultdict`  
`groups = defaultdict(list)` - в скобках передается указатель на класс объекта  

```
for student, group in students:  
    groups[group].append(student)  
print(groups)  
```  

`print(groups[3])` - обращение по ключу  
* обращение по несуществующему ключу возвращает пустой элемент, и в словаре создастся элемент с этим ключом с пустым значением  

:arrow_up:[К оглавлению](#оглавление)

---

#### ORDEREDDICT
Специальный словарь, который гарантирует сохранение ключей в порядке их добавления

`from collections import OrderedDict`  
`ordered_client_ages = OrderedDict(data)`  
```
# Сортируем по второму значению из кортежа, то есть по возрасту  
ordered_client_ages = OrderedDict(sorted(data, key=lambda x: x[1]))
```
* если добавить новый элемент в словарь - новая запись окажется в конце  
* до версии 3.7 не гарантируется сохранение порядка ключей в словаре
* узнать версию Python:  
```
import sys
print(sys.version)
```

:arrow_up:[К оглавлению](#оглавление)  

---

#### DEQUE
Очередь — это упорядоченный тип данных, который обладает двумя ключевыми функциями: добавление элемента в конец очереди и извлечение самого первого элемента из очереди. То есть очередь подразумевает, что тот элемент, который первым добавлен в очередь, будет первым потом и обработан. Всё как в обычной очереди! Этот принцип сокращённо также называется FIFO (от англ. First In — First Out, «первым пришёл — первым ушёл»).  

Стек (от англ. stack — стопка) — это упорядоченный тип данных, который обладает двумя основными функциями: добавление элемента в конец стека и извлечение элемента из конца стека. Эта структура данных также называется рюкзаком. Действительно, представьте себе, что вы набили вещами рюкзак. Теперь, когда вы решите достать из него самую верхнюю вещь, что это будет за вещь? Верно — та самая, которую вы убрали в рюкзак последней. Поэтому принцип стека (рюкзака) также сокращённо называется LIFO (Last In — First Out, «последним пришёл — первым ушёл»).

deque - double-ended queue — двухконцевая очередь.  
Она объединяет в себе возможности и стека, и очереди: содержит функции, которые позволяют добавлять элементы в начало или в конец очереди, а также извлекать первый или последний элемент из неё.

* Ключевые функции:  

№ п/п |код     | Описание
:----:|:------:|:----------:
1|append|добавить элемент в конец дека  
2|appendleft|добавить элемент в начало дека  
3|pop|удалить и вернуть элемент из конца дека  
4|popleft|удалить и вернуть элемент из начала дека  

* удаление элемента по индексу через `del ___[index]`  
* добавить несколько элементов `extend` и `extendleft`  
* очередь с ограниченной длиной `limited = deque(maxlen=3)`  
* поменять порядок элементов в очереди `reverse()`  
* перенести n-заданных элементов из конца в начало `rotate(-n)`  
* `index()` - позволяет найти первый индекс искомого элемента, `count()` - подсчитать сколько раз элемент встретился в очереди  
* `clear()` - позволяет очистить очередь

:arrow_up:[К оглавлению](#оглавление)  

---

### МОДУЛЬ NUMPY. ТИПЫ ДАННЫХ
Данная библиотека предназначена для точной и быстрой работы с числами.

#### ЦЕЛОЧИСЛЕННЫЕ ТИПЫ ДАННЫХ В NUMPY

[К модулю на SF](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/courseware/adcad86c8b6c4e1299c49876a3024181/d8f26eeaa369488fba89d80455b6e101/2?activate_block_id=block-v1%3ASkillFactory%2BDSPR-2.0%2B14JULY2021%2Btype%40vertical%2Bblock%4089fd876ec7b241e697f390c7d06f8dde)

* int8
* int16
* int32
* int64

* `np.iinfo()` - узнать границы int

Беззнаковые целочисленные типы данных:  
* uint (unsigned int — беззнаковое целое)

---

#### ТИПЫ ДАННЫХ С ПЛАВАЮЩЕЙ ТОЧКОЙ В NUMPY
Чтобы узнать границы:  

* `np.finfo()` (float info)

* np.float16
* np.float32
* np.float64
* np.float128

---

#### ДОПОЛНИТЕЛЬНЫЕ ТИПЫ ДАННЫХ В NUMPY

Полный список (а точнее, словарь) типов данных - `print(np.sctypeDict)`

Список уникальных типов данных -  
`print(*sorted(map(str, set(np.sctypeDict.values()))), sep='\n')`


:arrow_up:[К оглавлению](#оглавление)  

---

### МОДУЛЬ NUMPY. МАССИВЫ


#### Массивы

* Элементы хранятся в указаном порядке  
* Каждый элемент можно получить по индексу за одинаковое время
* Все элементы приведены к одному и тому же типу данных
* Максимальное число элементов и объем выделенной памяти заданы заранее

##### Размерность массива

> То число индексов, которое необходимо для однозначного получения элемента из массива.

---

#### МАССИВЫ В NUMPY

```
import numpy as np  
arr = np.array([1,5,2,9,10])
```
 

* узнать какой тип данных хранится в массиве:  
`arr.dtype`

* задать тип данных при создании массива:  
`arr = np.array([1,5,2,9,10], dtype=np.int8)`
`arr = np.float32(arr`

---

##### СВОЙСТВА NUMPY-МАССИВОВ

№ п/п |Свойство     | Описание
:----:|:-----------:|:----------:
1|`.ndim`|размерность массива  
2|`.size`|общее число элементов в массиве  
3|`.shape`|форма или структура массива  
4|`.itemsize`|сколько «весит» каждый элемент массива  


:arrow_up:[К оглавлению](#оглавление) 

---

##### ЗАПОЛНЕНИЕ НОВЫХ МАССИВОВ

№ п/п |Код     | Описание
:----:|:-----------:|:----------:
1|`np.zeros(n)`|создание нового одномерного массива из n-элементов  
2|`np.zeros((x, y, z))`|создание нового массива формой x*y*z  
3|`np.arrange(start, stop, step)`|как `range`, аргументы могут иметь тип `float`  
4|`np.linspace(start, stop, num, endpoint=True, retstep=False, dtype=)`| `retstep` - возвращать ли использованный шаг.  

:arrow_up:[К оглавлению](#оглавление) 

---

### 7. Модуль NumPy. Действия с массивами
[К модулю на SF](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/courseware/adcad86c8b6c4e1299c49876a3024181/d8f26eeaa369488fba89d80455b6e101/7?activate_block_id=block-v1%3ASkillFactory%2BDSPR-2.0%2B14JULY2021%2Btype%40vertical%2Bblock%4047874d7a4f8f435cb9a55e72ecef1439)


#### ДЕЙСТВИЯ С МАССИВАМИ

##### Изменение формы массива

* `arr.shape = (x, y)` - поменять форму массива
* `new_arr = arr.reshape((x, y))` - создать новый массив с другой формой
    + именованный агрумент `order`
        - `order='C'` - по умолчанию
        - `order='F'` - массив заполняется числами по столбцам
* `arr_trans = arr.transpose()` - транспонирование
    + при транспонировании одномерного массива его форма не меняется


:arrow_up:[К оглавлению](#оглавление) 

---

##### Индексы и срезы в массивах

* можно применять срезы сразу и к строкам и к столбцам:
`nd_array[1:, 2:4]`
* развернуть порядок:
`nd_array[1:, 2:4][::-1]`

:arrow_up:[К оглавлению](#оглавление) 

---

##### Сортировка одномерных массивов

.sort()
- либо присвоить результат новому массиву
- либо отсортирует исходный массив и вернет None

:arrow_up:[К оглавлению](#оглавление) 

---

##### Работа с пропущенными данными

* узнать какие данные пропущены nan: `np.isnan()`  
* узнать элементы `arr[np.isnan(arr)]`
* присвоить элементам новые значения `arr[np.isnan(arr)] = 0`

:arrow_up:[К оглавлению](#оглавление) 

---


### 8. Модуль NumPy. Операции с векторами


#### ВЕКТОРЫ В NUMPY И АРИФМЕТИКА
> Операция, применённая к двум векторам, на самом деле применяется поэлементно. То есть при сложении двух векторов первым элементом нового вектора будет сумма первых элементов исходных векторов, вторым — сумма вторых элементов и т. д. 



:arrow_up:[К оглавлению](#оглавление) 

---

#### ПРОДВИНУТЫЕ ОПЕРАЦИИ С ВЕКТОРАМИ


* определение длины вектора  
> Длиной вектора называют корень из суммы квадратов всех его координат. Для вектора из n чисел x1, x2 … xn верна формула:  
`len = (x1**2 + x2**2 + ... + xn**2)**0.5`
`length = np.sqrt(np.sum(vec ** 2))`
`length = np.linalg.norm(vec)`

* определение расстояния между двумя векторами
> Расстояние - квадратный корень из суммы квадратов разностей соответствующих координат.
> это длина такого вектора, который является разностью этих векторов. В самом деле, при вычитании двух векторов вычитаются их соответствующие координаты.  
`distance = np.sqrt(np.sum((vec1 - vec2) ** 2))`
`distance = np.linalg.norm(vec1 - vec2)`

* определение скалярного произведения векторов  
> Cкалярным произведением двух векторов называют сумму произведений их соответствующих координат.

`scalar_product = np.sum(vec1 * vec2)`
`scalar_product = np.dot(vec1, vec2)`


#### БАЗОВЫЕ СТАТИСТИЧЕСКИЕ ФУНКЦИИ ДЛЯ ВЕКТОРОВ

* определение минимального/максимального/среднего значения:  
`np.min(arr)`
`arr.min()`


### Модуль NumPy. Случайные числа

* генерация случайных чисел
* переменшивать элементы в массивах
* получить одинаковые наборы случайных чисел

#### СЛУЧАЙНЫЕ ЧИСЛА В NUMPY


##### ГЕНЕРАЦИЯ FLOAT
Для генерации псевдослучайных чисел в NumPy существует подмодуль random.  

`np.random.rand()` - генерирует числа в диапазоне от 0 до 1
* можно создать массив необходимого размера `np.random.rand(2, 3)
* в `rand` в качестве аргумента не может принять кортеж, его нужно распаковать (*)
* кортеж может принять аналогичная функция: `np.random.sample(shape)`


* для генерации чисел в заданом промежутке: `uniform(low= , high= , size= )`


##### ГЕНЕРАЦИЯ INT
`randint(low, high=None, size=None, dtype=int)`
* размер можно так же задать кортежем

##### ГЕНЕРАЦИЯ ВЫБОРОК
Перемешать все числа в массиве позволяет функция `random.shuffle(arr)` - перемешивает тот массив, к которому применяется и возвращает None

Для получения нового массива: `np.random.permutation(arr)`  

```
np.random.permutation(10)
# array([7, 8, 2, 9, 4, 3, 1, 0, 5, 6])
```

* Чтобы получить случайный набор объектов из массива, используется функция `random.choice(a, size=None, replace=True)`
`replace` — параметр, задающий, могут ли элементы повторяться (по умолчанию могут)


##### SEED ГЕНЕРАТОРА ПСЕВДОСЛУЧАЙНЫХ ЧИСЕЛ

`np.random.seed(23)`
