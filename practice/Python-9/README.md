# 1. Python-9

## Оглавление 
* [Модуль Collections](#модуль-collections-counter-и-defaultdict)  
    + [Counter](#counter)
    + [Defaultdict](#defaultdict)
    + [Orderdict](#ordereddict)
    + [Deque](#deque)
* [Модуль NumPy. Типы данных](#модуль-numpy-типы-данных)  
    + [Целочисленные типы](#целочисленные-типы-данных-в-numpy)
    + [С плавающей точкой](#типы-данных-с-плавающей-точкой-в-numpy)
    + [Дополнительные типы](#дополнительные-типы-данных-в-numpy)  
* [Модуль NumPy. Массивы](#модуль-numpy-типы-данных)  
    +[Массивы В NumPy](#массивы-в-numpy)


### Модуль Collections
- как подсчитывать элементы в списке с помощью объекта Counter;  
- как создавать словарь с заданным по умолчанию объектом для упрощения написания кода;  
- как создавать объекты deque и OrderedDict;  
- как применять возможности очереди и стека на практике;  
-  как определять ситуации, в которых необходимо использовать новые изученные объекты вместо привычных list и dict.


#### COUNTER
Предназначен для решения часто возникающей задачи по подсчёту различных элементов  

№ п/п |код     | Описание
:----:|:------:|:----------:
1     |`from collections import Counter`|
2     |`c = Counter(lst)`|узнать сколько раз встретился конкретный элемент
3     |`sum(c.values())`|узнать сумму всех значений
4     |`Counter(lst1) + Counter(lst2)`| 
5     |`Counter(lst1).substract(Counter(lst2))`| 
6     |`print(*Counter(lst1).elements())`|список всех элементов
7     |`print(list(Counter(lst1)))`|список уникальных элементов 
8     |`print(dict(Counter(lst1)))`|превратить Counter в обычный словарь
9     |`print(Counter(lst).most_common())`|список кортежей
10     |`print(Counter(lst).most_common(2))`|список из 2х кортежей
11     |`Counter(lst).clear()`|обнулить счетчик

:arrow_up:[К оглавлению](#оглавление)


#### DEFAULTDICT
Позволяет задавать тот тип данных, который хранится в словаре по умолчанию. Бывает удобно в том случае, если приходится заполнять одну и ту же структуру данных, экземпляр которой должен храниться по каждому ключу в словаре.  

`from collections import defaultdict`  
`groups = defaultdict(list)` - в скобках передается указатель на класс объекта  

```
for student, group in students:  
    groups[group].append(student)  
print(groups)  
```  

`print(groups[3])` - обращение по ключу  
* обращение по несуществующему ключу возвращает пустой элемент, и в словаре создастся элемент с этим ключом с пустым значением  

:arrow_up:[К оглавлению](#оглавление)


#### ORDEREDDICT
Специальный словарь, который гарантирует сохранение ключей в порядке их добавления

`from collections import OrderedDict`  
`ordered_client_ages = OrderedDict(data)`  
```
# Сортируем по второму значению из кортежа, то есть по возрасту  
ordered_client_ages = OrderedDict(sorted(data, key=lambda x: x[1]))
```
* если добавить новый элемент в словарь - новая запись окажется в конце  
* до версии 3.7 не гарантируется сохранение порядка ключей в словаре
* узнать версию Python:  
```
import sys
print(sys.version)
```

:arrow_up:[К оглавлению](#оглавление)  


#### DEQUE
Очередь — это упорядоченный тип данных, который обладает двумя ключевыми функциями: добавление элемента в конец очереди и извлечение самого первого элемента из очереди. То есть очередь подразумевает, что тот элемент, который первым добавлен в очередь, будет первым потом и обработан. Всё как в обычной очереди! Этот принцип сокращённо также называется FIFO (от англ. First In — First Out, «первым пришёл — первым ушёл»).  

Стек (от англ. stack — стопка) — это упорядоченный тип данных, который обладает двумя основными функциями: добавление элемента в конец стека и извлечение элемента из конца стека. Эта структура данных также называется рюкзаком. Действительно, представьте себе, что вы набили вещами рюкзак. Теперь, когда вы решите достать из него самую верхнюю вещь, что это будет за вещь? Верно — та самая, которую вы убрали в рюкзак последней. Поэтому принцип стека (рюкзака) также сокращённо называется LIFO (Last In — First Out, «последним пришёл — первым ушёл»).

deque - double-ended queue — двухконцевая очередь.  
Она объединяет в себе возможности и стека, и очереди: содержит функции, которые позволяют добавлять элементы в начало или в конец очереди, а также извлекать первый или последний элемент из неё.

* Ключевые функции:  

№ п/п |код     | Описание
:----:|:------:|:----------:
1|append|добавить элемент в конец дека  
2|appendleft|добавить элемент в начало дека  
3|pop|удалить и вернуть элемент из конца дека  
4|popleft|удалить и вернуть элемент из начала дека  

* удаление элемента по индексу через `del ___[index]`  
* добавить несколько элементов `extend` и `extendleft`  
* очередь с ограниченной длиной `limited = deque(maxlen=3)`  
* поменять порядок элементов в очереди `reverse()`  
* перенести n-заданных элементов из конца в начало `rotate(-n)`  
* `index()` - позволяет найти первый индекс искомого элемента, `count()` - подсчитать сколько раз элемент встретился в очереди  
* `clear()` - позволяет очистить очередь

:arrow_up:[К оглавлению](#оглавление)  


### Модуль NumPy. Типы данных
Данная библиотека предназначена для точной и быстрой работы с числами.

#### ЦЕЛОЧИСЛЕННЫЕ ТИПЫ ДАННЫХ В NUMPY

[К модулю на SF](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/courseware/adcad86c8b6c4e1299c49876a3024181/d8f26eeaa369488fba89d80455b6e101/2?activate_block_id=block-v1%3ASkillFactory%2BDSPR-2.0%2B14JULY2021%2Btype%40vertical%2Bblock%4089fd876ec7b241e697f390c7d06f8dde)

* int8
* int16
* int32
* int64

* `np.iinfo()` - узнать границы int

Беззнаковые целочисленные типы данных:  
* uint (unsigned int — беззнаковое целое)


#### ТИПЫ ДАННЫХ С ПЛАВАЮЩЕЙ ТОЧКОЙ В NUMPY
Чтобы узнать границы:  

* `np.finfo()` (float info)

* np.float16
* np.float32
* np.float64
* np.float128

#### ДОПОЛНИТЕЛЬНЫЕ ТИПЫ ДАННЫХ В NUMPY

Полный список (а точнее, словарь) типов данных - `print(np.sctypeDict)`

Список уникальных типов данных -  
`print(*sorted(map(str, set(np.sctypeDict.values()))), sep='\n')`


:arrow_up:[К оглавлению](#оглавление)  


### Модуль NumPy. Массивы


#### Массивы

* Элементы хранятся в указаном порядке  
* Каждый элемент можно получить по индексу за одинаковое время
* Все элементы приведены к одному и тому же типу данных
* Максимальное число элементов и объем выделенной памяти заданы заранее

##### Размерность массива

> То число индексов, которое необходимо для однозначного получения элемента из массива.

#### МАССИВЫ В NUMPY

```import numpy as np  
arr = np.array([1,5,2,9,10])
```
 

* узнать какой тип данных хранится в массиве:  
`arr.dtype`

* задать тип данных при создании массива:  
arr = np.array([1,5,2,9,10], dtype=np.int8)`


##### СВОЙСТВА NUMPY-МАССИВОВ

№ п/п |Свойство     | Описание
:----:|:-----------:|:----------:
1|`.ndim`|размерность массива  
2|`.size`|общее число элементов в массиве  
3|`.shape`|форма или структура массива  
4|`.itemsize`|сколько «весит» каждый элемент массива  


:arrow_up:[К оглавлению](#оглавление) 